function slp_fmm = surf_integral(posint, r, dSx, dSy, dSz, targ, bie_f, ndir)
% posint = center of square faces : size should be 3 x something
% bie_f also has 3 x something form
% targ = target points
eps = 1e-10;

% few setups 
pg = 1;
pgt = 1;

ns = size(posint,2);
srcinfo.sources = posint; %xj (3 x N)

ntarg = size(targ,2);

% We compute each element in the volume integral 
%% part 1
slp_pt1 = zeros(3, ntarg);
slp_pt2 = zeros(3, ntarg);

H_part = zeros(1, ntarg);
H2_part = zeros(1, ntarg);

posint_n = [0; 0; 0];
for j = 1:3
    
    for nn = 1:ns
        normal_dir = ndir(nn);
        bie_f_n = bie_f(:,nn);
        
        
        if normal_dir == 1
            
            ySpan = (-r+posint(2,nn)) + dSy : dSy : (r+posint(2,nn)) - dSy;
            zSpan = (-r+posint(3,nn)) + dSz : dSz : (r+posint(3,nn)) - dSz;
            xSpan = posint(1,nn).*ones(1, length(ySpan));
            
            posint_all = make_grid(xSpan, ySpan, zSpan);

            H_part = H_part + ...
                (dSy*dSz).*sur_fmm_Hsum(j, bie_f_n, posint_all, eps, pg, targ, pgt);
            
            H2_part = H2_part + ...
                (dSy*dSz).*sur_fmm_Hsum2(j, ns, bie_f, eps, srcinfo, pg, targ, pgt);

        elseif normal_dir == 2
            xSpan = (-r+posint(1,nn)) + dSx : dSx : (r+posint(1,nn)) - dSx;
            ySpan = posint(2,nn).*ones(1, length(ySpan);
            zSpan = (-r+posint(3,nn)) + dSz : dSz : (r+posint(3,nn)) - dSz;
            
            posint_all = make_grid(xSpan, ySpan, zSpan);

           
            for xx = 1:length(xSpan)
                posint_n(2) = ySpan;
                posint_n(1) = xSpan(xx);
                
                for zz = 1:length(zSpan)
                    posint_n(3) = zSpan(zz);
                    H_part = H_part + ...
                        (dSx*dSz).*sur_fmm_Hsum(j, ns, bie_f_n, posint_n, eps, srcinfo, pg, targ, pgt);
                    
                    H2_part = H2_part + ...
                        (dSx*dSz).*sur_fmm_Hsum2(j, ns, bie_f, eps, srcinfo, pg, targ, pgt);
                end
                
            end
            
        else %normal dir = 3
            xSpan = (-r+posint(1,nn)) + dSx : dSx : (r+posint(1,nn)) - dSx;
            ySpan = (-r+posint(2,nn)) + dSy : dSy : (r+posint(2,nn)) - dSy;
            zSpan = posint(3,nn);
            
            for xx = 1:length(xSpan)
                posint_n(3) = zSpan;
                posint_n(1) = xSpan(xx);
                
                for yy = 1:length(ySpan)
                    posint_n(2) = ySpan(yy);
                    H_part = H_part + ...
                        (dSx*dSy).*sur_fmm_Hsum(j, ns, bie_f_n, posint_n, eps, srcinfo, pg, targ, pgt);
                    
                    H2_part = H2_part + ...
                        (dSx*dSy).*sur_fmm_Hsum2(j, ns, bie_f, eps, srcinfo, pg, targ, pgt);
                end
                
            end
            
            
        end
        
        slp_pt1(j,:) = H_part;
        slp_pt2(j,:) = H2_part;
    end
end


%% Finalize 
slp_fmm = slp_pt1 + slp_pt2;

% Add one more part : direct computation when source == targ

end




